/*
Raylib example file.
This is an example main file for a simple raylib project.
Use this as a starting point or replace it with your code.

by Jeffery Myers is marked with CC0 1.0. To view a copy of this license, visit https://creativecommons.org/publicdomain/zero/1.0/

*/

#include <vector>

#include "raylib.h"
#include "resource_dir.h"	
#include "Player.hpp"
#include "Block.hpp"
#include "Goomba.hpp"
#include "GameManager.hpp"
#include "SurpriseBlock.hpp"
#include"NormalBlock.hpp"
#include"GameCamera.hpp"
#include"Star.hpp"
#include"Mushroom.hpp"
#include"Flower.hpp"

using namespace std;

#define GRAVITY  20.0f    // GRAVITY IN EACH FRAME
#define JUMP_FORCE 350.0f // JUMP FORCE
#define TILE_SIZE 16.0f  // MINIMUM TILE SIZE

int main()
{
	// Tell the window to use vsync and work on high DPI displays
	SetConfigFlags(FLAG_VSYNC_HINT | FLAG_WINDOW_HIGHDPI);

	//define the width and height of the screen
	const int screenWidth = 512;
	const int screenHeight = 448;

	InitWindow(screenWidth, screenHeight, "Super MarioBros"); //Initialize the screen
	InitAudioDevice(); //Initialize audio device for the sounds

	GameManager gm(1, 0); //create a game manager for controlling the game flow
	Player* mario = new Player(300.0f, 100.0f, TILE_SIZE, TILE_SIZE * 2, 0, 2, 0, 0, 200.0f, 1, 0); //create Mario
	GameCamera camera(screenWidth, 0, 3584); //create the camera

	// game loop
	while (!WindowShouldClose())// run the loop untill the user presses ESCAPE or presses the Close button on the window
	{
		gm.playSounds(); //this will call all the sounds

		if (mario->getHitbox().x >= 3300) { //If mario arrives to the end of the level

			gm.win(); //call win function

			//this will delete mario and liberate it's memory and replace it with another mario with the values reseted
			delete mario;
			mario = new Player(300.0f, 100.0f, TILE_SIZE, TILE_SIZE * 2, 0, 2, 0, 0, 200.0f, 1, 0);

			gm.die(); //for the game manager to know that the level has ended and another new level could be started
			camera.reset(); //reset camera position
		}

		if (mario->getState() == 0) { //If mario dies

			gm.gameOver(); //call game over function

			//this will delete mario and liberate it's memory and replace it with another mario with the values reseted
			delete mario;
			mario = new Player(300.0f, 100.0f, TILE_SIZE, TILE_SIZE * 2, 0, 2, 0, 0, 200.0f, 1, 0);

			gm.die(); //for the game manager to know that the level has ended and another new level could be started
			camera.reset(); //reset camera position
		}

		//Go to the next screen
		if (IsKeyPressed(KEY_N)) {
			gm.nextScreen();
		}

		if (gm.GetScreen() == 2) { // for choosing an option in the main menu

			gm.opSelector();
		}

		//--------------------------//
		//---------GAME LOGIC-------// Apply only when we are in the game screen [0]
		//--------------------------//

		if (gm.GetScreen() == 0) {

			//restart the level and build again all the blocks and the enemies
			if (!gm.getlevelStarted()) {

				gm.startLevel(gm.getAllEntities());

				for (int i = 0; i < gm.getAllEntities().size();i++) {
					printf("Entity id: %d| state: %d\n", gm.getAllEntities()[i]->getId(), gm.getAllEntities()[i]->getState());
				}
				gm.mapCreated();
			}

			//-----MARIO CONTROLS--------//
			mario->applyGravity(GRAVITY);
			mario->updateRects(); //updating the middle points of the hitbox at every moment when it move

			if (IsKeyDown(KEY_RIGHT)) {

				if (mario->getDir() != 1) {

					printf("chage direction to right");

					mario->changeDirection();
				}

				if (mario->getDir() == 1) { // if I am going right

					mario->move(1, camera.getRawCamera().target.x); //move to the right
				}
				mario->isWalkingTrue();
			}

			if (IsKeyDown(KEY_LEFT)) {

				if (mario->getDir() == 1) {

					printf("chage direction to left");

					mario->changeDirection();
				}

				if (mario->getDir() != 1) { // if I am going left

					mario->move(-1, camera.getRawCamera().target.x); //move to the left
				}
				mario->isWalkingTrue();
			}


			if (IsKeyReleased(KEY_RIGHT) || IsKeyReleased(KEY_LEFT)) {
				printf("key released");

				mario->isWalkingFalse();
			}

			mario->colisionsPlayer(gm.getAllEntities());

			if (mario->retImmunity()) {

				mario->immunityVoid();
			}

			if (IsKeyPressed(KEY_SPACE) && !mario->retJumping()) {

				mario->jump(JUMP_FORCE);
			}

			//------IA CONTROLS------//

			auto& entities = gm.getAllEntities();

			for (auto it = entities.begin(); it != entities.end(); ) {
				Goomba* g = dynamic_cast<Goomba*>(*it);
				if (g != nullptr) {
					g->updateRects();
					g->moveGoomba(entities, GRAVITY);  // Move separately if needed

					if (g->isMarkedForDeletion()) {
						delete* it;
						it = entities.erase(it);  // Correct way to delete while iterating
						continue;
					}
				}

				// Safe polymorphic update
				(*it)->update(entities, GRAVITY);

				// Update specific power-ups if needed
				if (Star* s = dynamic_cast<Star*>(*it)) {
					s->update(GRAVITY);
				}
				if (Mushroom* m = dynamic_cast<Mushroom*>(*it)) {
					m->update(GRAVITY);
				}
				if (Flower* f = dynamic_cast<Flower*>(*it)) {
					f->update(GRAVITY);
				}

				++it;
			}


			//------CAMERA CONTROLS------//
			camera.update(mario->getHitbox());
		}
		
		//-------------------------------------------DRAWING-----------------------------------------------------------//

		BeginDrawing();

		// Setup the back buffer for drawing (clear color and depth buffers)
		ClearBackground(BLACK);

		//draw the corresponding screens
		gm.drawScreen(camera.getRawCamera(), screenWidth, screenHeight);

		//if we are in the main menu draw the arrow for selecting an option
		if (gm.GetScreen() == 2) {

			gm.drawArrow();
		}

		//Draw the in-game characters and scenario and begin the camera mode
		if (gm.GetScreen() == 0) {

			camera.begin();
			mario->draw();

			//draw all the entities
			for (int i = 0; i < gm.getAllEntities().size(); ++i) { 

				gm.getAllEntities()[i]->draw();

			}

		}

		DrawText(TextFormat("Is walking = %d", mario->retIsWalking()), 10, 10, 20, BLACK);
		DrawText(TextFormat("Souns played = %d", gm.retSound()), 10, 30, 20, BLACK);

		//end camera mode
		camera.end();

		// end drawing and the frame and get ready for the next one  (display frame, poll input, etc...)
		EndDrawing();
	}

	//finish the audio device
	CloseAudioDevice();

	// destroy the window and cleanup the OpenGL context
	CloseWindow();
	return 0;
}
